/* automatically generated by rust-bindgen */

pub const ZSTD_VERSION_MAJOR: ::libc::c_uint = 1;
pub const ZSTD_VERSION_MINOR: ::libc::c_uint = 2;
pub const ZSTD_VERSION_RELEASE: ::libc::c_uint = 0;
pub const ZSTD_VERSION_NUMBER: ::libc::c_uint = 10200;
pub const ZSTD_MAGICNUMBER: ::libc::c_uint = 4247762216;
pub const ZSTD_MAGIC_SKIPPABLE_START: ::libc::c_uint = 407710288;
pub const ZSTD_CONTENTSIZE_UNKNOWN: ::libc::c_int = -1;
pub const ZSTD_CONTENTSIZE_ERROR: ::libc::c_int = -2;
pub const ZSTD_WINDOWLOG_MAX_32: ::libc::c_uint = 27;
pub const ZSTD_WINDOWLOG_MAX_64: ::libc::c_uint = 27;
pub const ZSTD_WINDOWLOG_MIN: ::libc::c_uint = 10;
pub const ZSTD_HASHLOG_MIN: ::libc::c_uint = 6;
pub const ZSTD_CHAINLOG_MIN: ::libc::c_uint = 6;
pub const ZSTD_HASHLOG3_MAX: ::libc::c_uint = 17;
pub const ZSTD_SEARCHLOG_MIN: ::libc::c_uint = 1;
pub const ZSTD_SEARCHLENGTH_MAX: ::libc::c_uint = 7;
pub const ZSTD_SEARCHLENGTH_MIN: ::libc::c_uint = 3;
pub const ZSTD_TARGETLENGTH_MIN: ::libc::c_uint = 4;
pub const ZSTD_TARGETLENGTH_MAX: ::libc::c_uint = 999;
pub const ZSTD_FRAMEHEADERSIZE_MAX: ::libc::c_uint = 18;
pub const ZSTD_FRAMEHEADERSIZE_MIN: ::libc::c_uint = 6;
pub const ZSTD_BLOCKSIZE_ABSOLUTEMAX: ::libc::c_uint = 131072;
pub type wchar_t = ::libc::c_int;
extern "C" {
    pub fn ZSTD_versionNumber() -> ::libc::c_uint;
}
extern "C" {
    /***************************************
    *  Simple API
    ***************************************/
    /** ZSTD_compress() :
     *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
     *  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
     *  @return : compressed size written into `dst` (<= `dstCapacity),
     *            or an error code if it fails (which can be tested using ZSTD_isError()). */
    pub fn ZSTD_compress(dst: *mut ::libc::c_void, dstCapacity: usize,
                         src: *const ::libc::c_void, srcSize: usize,
                         compressionLevel: ::libc::c_int)
                         -> usize;
}
extern "C" {
    /** ZSTD_decompress() :
     *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
     *  `dstCapacity` is an upper bound of originalSize.
     *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
     *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
     *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */
    pub fn ZSTD_decompress(dst: *mut ::libc::c_void, dstCapacity: usize,
                           src: *const ::libc::c_void, compressedSize: usize)
                           -> usize;
}
extern "C" {
    /** ZSTD_getDecompressedSize() :
     *  NOTE: This function is planned to be obsolete, in favour of ZSTD_getFrameContentSize.
     *  ZSTD_getFrameContentSize functions the same way, returning the decompressed size of a single
     *  frame, but distinguishes empty frames from frames with an unknown size, or errors.
     *
     *  Additionally, ZSTD_findDecompressedSize can be used instead.  It can handle multiple
     *  concatenated frames in one buffer, and so is more general.
     *  As a result however, it requires more computation and entire frames to be passed to it,
     *  as opposed to ZSTD_getFrameContentSize which requires only a single frame's header.
     *
     *  'src' is the start of a zstd compressed frame.
     *  @return : content size to be decompressed, as a 64-bits value _if known_, 0 otherwise.
     *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
     *            When `return==0`, data to decompress could be any size.
     *            In which case, it's necessary to use streaming mode to decompress data.
     *            Optionally, application can still use ZSTD_decompress() while relying on implied limits.
     *            (For example, data may be necessarily cut into blocks <= 16 KB).
     *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
     *   note 3 : decompressed size can be very large (64-bits value),
     *            potentially larger than what local system can handle as a single memory segment.
     *            In which case, it's necessary to use streaming mode to decompress data.
     *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
     *            Always ensure result fits within application's authorized limits.
     *            Each application can set its own limits.
     *   note 5 : when `return==0`, if precise failure cause is needed, use ZSTD_getFrameParams() to know more. */
    pub fn ZSTD_getDecompressedSize(src: *const ::libc::c_void,
                                    srcSize: usize)
                                    -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn ZSTD_maxCLevel() -> ::libc::c_int;
}
extern "C" {
    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
}
extern "C" {
    pub fn ZSTD_isError(code: usize) -> ::libc::c_uint;
}
extern "C" {
    pub fn ZSTD_getErrorName(code: usize) -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_s {
    _unused: [u8; 0],
}
/***************************************
*  Explicit memory management
***************************************/
pub type ZSTD_CCtx = ZSTD_CCtx_s;
extern "C" {
    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
}
extern "C" {
    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
}
extern "C" {
    /** ZSTD_compressCCtx() :
     *  Same as ZSTD_compress(), requires an allocated ZSTD_CCtx (see ZSTD_createCCtx()). */
    pub fn ZSTD_compressCCtx(ctx: *mut ZSTD_CCtx, dst: *mut ::libc::c_void,
                             dstCapacity: usize, src: *const ::libc::c_void,
                             srcSize: usize, compressionLevel: ::libc::c_int)
                             -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_DCtx = ZSTD_DCtx_s;
extern "C" {
    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
}
extern "C" {
    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    /** ZSTD_decompressDCtx() :
     *  Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx (see ZSTD_createDCtx()). */
    pub fn ZSTD_decompressDCtx(ctx: *mut ZSTD_DCtx,
                               dst: *mut ::libc::c_void, dstCapacity: usize,
                               src: *const ::libc::c_void, srcSize: usize)
                               -> usize;
}
extern "C" {
    /**************************
    *  Simple dictionary API
    ***************************/
    /** ZSTD_compress_usingDict() :
    *   Compression using a predefined Dictionary (see dictBuilder/zdict.h).
    *   Note : This function loads the dictionary, resulting in significant startup delay.
    *   Note : When `dict == NULL || dictSize < 8` no dictionary is used. */
    pub fn ZSTD_compress_usingDict(ctx: *mut ZSTD_CCtx,
                                   dst: *mut ::libc::c_void,
                                   dstCapacity: usize,
                                   src: *const ::libc::c_void,
                                   srcSize: usize,
                                   dict: *const ::libc::c_void,
                                   dictSize: usize,
                                   compressionLevel: ::libc::c_int)
                                   -> usize;
}
extern "C" {
    /** ZSTD_decompress_usingDict() :
    *   Decompression using a predefined Dictionary (see dictBuilder/zdict.h).
    *   Dictionary must be identical to the one used during compression.
    *   Note : This function loads the dictionary, resulting in significant startup delay.
    *   Note : When `dict == NULL || dictSize < 8` no dictionary is used. */
    pub fn ZSTD_decompress_usingDict(dctx: *mut ZSTD_DCtx,
                                     dst: *mut ::libc::c_void,
                                     dstCapacity: usize,
                                     src: *const ::libc::c_void,
                                     srcSize: usize,
                                     dict: *const ::libc::c_void,
                                     dictSize: usize)
                                     -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CDict_s {
    _unused: [u8; 0],
}
/****************************
*  Fast dictionary API
****************************/
pub type ZSTD_CDict = ZSTD_CDict_s;
extern "C" {
    /** ZSTD_createCDict() :
    *   When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once.
    *   ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.
    *   ZSTD_CDict can be created once and used by multiple threads concurrently, as its usage is read-only.
    *   `dictBuffer` can be released after ZSTD_CDict creation, as its content is copied within CDict */
    pub fn ZSTD_createCDict(dictBuffer: *const ::libc::c_void,
                            dictSize: usize, compressionLevel: ::libc::c_int)
                            -> *mut ZSTD_CDict;
}
extern "C" {
    /** ZSTD_freeCDict() :
    *   Function frees memory allocated by ZSTD_createCDict(). */
    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
}
extern "C" {
    /** ZSTD_compress_usingCDict() :
     *  Compression using a digested Dictionary.
     *  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.
     *  Note that compression level is decided during dictionary creation.
     *  Frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) */
    pub fn ZSTD_compress_usingCDict(cctx: *mut ZSTD_CCtx,
                                    dst: *mut ::libc::c_void,
                                    dstCapacity: usize,
                                    src: *const ::libc::c_void,
                                    srcSize: usize, cdict: *const ZSTD_CDict)
                                    -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DDict_s {
    _unused: [u8; 0],
}
pub type ZSTD_DDict = ZSTD_DDict_s;
extern "C" {
    /** ZSTD_createDDict() :
    *   Create a digested dictionary, ready to start decompression operation without startup delay.
    *   dictBuffer can be released after DDict creation, as its content is copied inside DDict */
    pub fn ZSTD_createDDict(dictBuffer: *const ::libc::c_void,
                            dictSize: usize)
                            -> *mut ZSTD_DDict;
}
extern "C" {
    /** ZSTD_freeDDict() :
    *   Function frees memory allocated with ZSTD_createDDict() */
    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
}
extern "C" {
    /** ZSTD_decompress_usingDDict() :
    *   Decompression using a digested Dictionary.
    *   Faster startup than ZSTD_decompress_usingDict(), recommended when same dictionary is used multiple times. */
    pub fn ZSTD_decompress_usingDDict(dctx: *mut ZSTD_DCtx,
                                      dst: *mut ::libc::c_void,
                                      dstCapacity: usize,
                                      src: *const ::libc::c_void,
                                      srcSize: usize,
                                      ddict: *const ZSTD_DDict)
                                      -> usize;
}
/****************************
*  Streaming
****************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_inBuffer_s {
    /**< start of input buffer */
    pub src: *const ::libc::c_void,
    /**< size of input buffer */
    pub size: usize,
    /**< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size */
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_inBuffer_s() {
    assert_eq!(::core::mem::size_of::<ZSTD_inBuffer_s>(),
               24usize,
               concat!("Size of: ", stringify!(ZSTD_inBuffer_s)));
    assert_eq!(::core::mem::align_of::<ZSTD_inBuffer_s>(),
               8usize,
               concat!("Alignment of ", stringify!(ZSTD_inBuffer_s)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_inBuffer_s)).src as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_inBuffer_s),
                       "::",
                       stringify!(src)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_inBuffer_s)).size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_inBuffer_s),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_inBuffer_s)).pos as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_inBuffer_s),
                       "::",
                       stringify!(pos)));
}
impl Clone for ZSTD_inBuffer_s {
    fn clone(&self) -> Self {
        *self
    }
}
pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_outBuffer_s {
    /**< start of output buffer */
    pub dst: *mut ::libc::c_void,
    /**< size of output buffer */
    pub size: usize,
    /**< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size */
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZSTD_outBuffer_s() {
    assert_eq!(::core::mem::size_of::<ZSTD_outBuffer_s>(),
               24usize,
               concat!("Size of: ", stringify!(ZSTD_outBuffer_s)));
    assert_eq!(::core::mem::align_of::<ZSTD_outBuffer_s>(),
               8usize,
               concat!("Alignment of ", stringify!(ZSTD_outBuffer_s)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_outBuffer_s)).dst as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_outBuffer_s),
                       "::",
                       stringify!(dst)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_outBuffer_s)).size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_outBuffer_s),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_outBuffer_s)).pos as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_outBuffer_s),
                       "::",
                       stringify!(pos)));
}
impl Clone for ZSTD_outBuffer_s {
    fn clone(&self) -> Self {
        *self
    }
}
pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CStream_s {
    _unused: [u8; 0],
}
pub type ZSTD_CStream = ZSTD_CStream_s;
extern "C" {
    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream(zcs: *mut ZSTD_CStream,
                            compressionLevel: ::libc::c_int)
                            -> usize;
}
extern "C" {
    pub fn ZSTD_compressStream(zcs: *mut ZSTD_CStream,
                               output: *mut ZSTD_outBuffer,
                               input: *mut ZSTD_inBuffer)
                               -> usize;
}
extern "C" {
    pub fn ZSTD_flushStream(zcs: *mut ZSTD_CStream,
                            output: *mut ZSTD_outBuffer)
                            -> usize;
}
extern "C" {
    pub fn ZSTD_endStream(zcs: *mut ZSTD_CStream,
                          output: *mut ZSTD_outBuffer)
                          -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_CStreamOutSize() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DStream_s {
    _unused: [u8; 0],
}
pub type ZSTD_DStream = ZSTD_DStream_s;
extern "C" {
    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressStream(zds: *mut ZSTD_DStream,
                                 output: *mut ZSTD_outBuffer,
                                 input: *mut ZSTD_inBuffer)
                                 -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamInSize() -> usize;
}
extern "C" {
    pub fn ZSTD_DStreamOutSize() -> usize;
}
pub const ZSTD_frameHeaderSize_prefix: usize = 5;
pub const ZSTD_frameHeaderSize_min: usize = 6;
pub const ZSTD_frameHeaderSize_max: usize = 18;
pub const ZSTD_skippableHeaderSize: usize = 8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_strategy {
    ZSTD_fast = 0,
    ZSTD_dfast = 1,
    ZSTD_greedy = 2,
    ZSTD_lazy = 3,
    ZSTD_lazy2 = 4,
    ZSTD_btlazy2 = 5,
    ZSTD_btopt = 6,
    ZSTD_btopt2 = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_compressionParameters {
    /**< largest match distance : larger == more compression, more memory needed during decompression */
    pub windowLog: ::libc::c_uint,
    /**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */
    pub chainLog: ::libc::c_uint,
    /**< dispatch table : larger == faster, more memory */
    pub hashLog: ::libc::c_uint,
    /**< nb of searches : larger == more compression, slower */
    pub searchLog: ::libc::c_uint,
    /**< match length searched : larger == faster decompression, sometimes less compression */
    pub searchLength: ::libc::c_uint,
    /**< acceptable match size for optimal parser (only) : larger == more compression, slower */
    pub targetLength: ::libc::c_uint,
    pub strategy: ZSTD_strategy,
}
#[test]
fn bindgen_test_layout_ZSTD_compressionParameters() {
    assert_eq!(::core::mem::size_of::<ZSTD_compressionParameters>(),
               28usize,
               concat!("Size of: ", stringify!(ZSTD_compressionParameters)));
    assert_eq!(::core::mem::align_of::<ZSTD_compressionParameters>(),
               4usize,
               concat!("Alignment of ",
                       stringify!(ZSTD_compressionParameters)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).windowLog as
                   *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(windowLog)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).chainLog as
                   *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(chainLog)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).hashLog as
                   *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(hashLog)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).searchLog as
                   *const _ as usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(searchLog)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).searchLength as
                   *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(searchLength)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).targetLength as
                   *const _ as usize
               },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(targetLength)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_compressionParameters)).strategy as
                   *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_compressionParameters),
                       "::",
                       stringify!(strategy)));
}
impl Clone for ZSTD_compressionParameters {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_frameParameters {
    /**< 1: content size will be in frame header (when known) */
    pub contentSizeFlag: ::libc::c_uint,
    /**< 1: generate a 32-bits checksum at end of frame, for error detection */
    pub checksumFlag: ::libc::c_uint,
    /**< 1: no dictID will be saved into frame header (if dictionary compression) */
    pub noDictIDFlag: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_ZSTD_frameParameters() {
    assert_eq!(::core::mem::size_of::<ZSTD_frameParameters>(),
               12usize,
               concat!("Size of: ", stringify!(ZSTD_frameParameters)));
    assert_eq!(::core::mem::align_of::<ZSTD_frameParameters>(),
               4usize,
               concat!("Alignment of ", stringify!(ZSTD_frameParameters)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParameters)).contentSizeFlag as
                   *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParameters),
                       "::",
                       stringify!(contentSizeFlag)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParameters)).checksumFlag as
                   *const _ as usize
               },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParameters),
                       "::",
                       stringify!(checksumFlag)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParameters)).noDictIDFlag as
                   *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParameters),
                       "::",
                       stringify!(noDictIDFlag)));
}
impl Clone for ZSTD_frameParameters {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_parameters {
    pub cParams: ZSTD_compressionParameters,
    pub fParams: ZSTD_frameParameters,
}
#[test]
fn bindgen_test_layout_ZSTD_parameters() {
    assert_eq!(::core::mem::size_of::<ZSTD_parameters>(),
               40usize,
               concat!("Size of: ", stringify!(ZSTD_parameters)));
    assert_eq!(::core::mem::align_of::<ZSTD_parameters>(),
               4usize,
               concat!("Alignment of ", stringify!(ZSTD_parameters)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_parameters)).cParams as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_parameters),
                       "::",
                       stringify!(cParams)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_parameters)).fParams as *const _ as
                   usize
               },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_parameters),
                       "::",
                       stringify!(fParams)));
}
impl Clone for ZSTD_parameters {
    fn clone(&self) -> Self {
        *self
    }
}
pub type ZSTD_allocFunction =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut ::libc::c_void,
                                                size: usize)
                                                -> *mut ::libc::c_void>;
pub type ZSTD_freeFunction =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut ::libc::c_void,
                                                address: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_customMem {
    pub customAlloc: ZSTD_allocFunction,
    pub customFree: ZSTD_freeFunction,
    pub opaque: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_ZSTD_customMem() {
    assert_eq!(::core::mem::size_of::<ZSTD_customMem>(),
               24usize,
               concat!("Size of: ", stringify!(ZSTD_customMem)));
    assert_eq!(::core::mem::align_of::<ZSTD_customMem>(),
               8usize,
               concat!("Alignment of ", stringify!(ZSTD_customMem)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_customMem)).customAlloc as *const _ as
                   usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_customMem),
                       "::",
                       stringify!(customAlloc)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_customMem)).customFree as *const _ as
                   usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_customMem),
                       "::",
                       stringify!(customFree)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_customMem)).opaque as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_customMem),
                       "::",
                       stringify!(opaque)));
}
impl Clone for ZSTD_customMem {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    /** ZSTD_findFrameCompressedSize() :
     *  `src` should point to the start of a ZSTD encoded frame or skippable frame
     *  `srcSize` must be at least as large as the frame
     *  @return : the compressed size of the frame pointed to by `src`, suitable to pass to
     *      `ZSTD_decompress` or similar, or an error code if given invalid input. */
    pub fn ZSTD_findFrameCompressedSize(src: *const ::libc::c_void,
                                        srcSize: usize)
                                        -> usize;
}
extern "C" {
    /***************************************
    *  Decompressed size functions
    ***************************************/
    /** ZSTD_getFrameContentSize() :
    *   `src` should point to the start of a ZSTD encoded frame
    *   `srcSize` must be at least as large as the frame header.  A value greater than or equal
    *       to `ZSTD_frameHeaderSize_max` is guaranteed to be large enough in all cases.
    *   @return : decompressed size of the frame pointed to be `src` if known, otherwise
    *             - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
    *             - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) */
    pub fn ZSTD_getFrameContentSize(src: *const ::libc::c_void,
                                    srcSize: usize)
                                    -> ::libc::c_ulonglong;
}
extern "C" {
    /** ZSTD_findDecompressedSize() :
    *   `src` should point the start of a series of ZSTD encoded and/or skippable frames
    *   `srcSize` must be the _exact_ size of this series
    *       (i.e. there should be a frame boundary exactly `srcSize` bytes after `src`)
    *   @return : the decompressed size of all data in the contained frames, as a 64-bit value _if known_
    *             - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
    *             - if an error occurred: ZSTD_CONTENTSIZE_ERROR
    *
    *    note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
    *             When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
    *             In which case, it's necessary to use streaming mode to decompress data.
    *             Optionally, application can still use ZSTD_decompress() while relying on implied limits.
    *             (For example, data may be necessarily cut into blocks <= 16 KB).
    *    note 2 : decompressed size is always present when compression is done with ZSTD_compress()
    *    note 3 : decompressed size can be very large (64-bits value),
    *             potentially larger than what local system can handle as a single memory segment.
    *             In which case, it's necessary to use streaming mode to decompress data.
    *    note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
    *             Always ensure result fits within application's authorized limits.
    *             Each application can set its own limits.
    *    note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
    *             read each contained frame header.  This is efficient as most of the data is skipped,
    *             however it does mean that all frame data must be present and valid. */
    pub fn ZSTD_findDecompressedSize(src: *const ::libc::c_void,
                                     srcSize: usize)
                                     -> ::libc::c_ulonglong;
}
extern "C" {
    /***************************************
    *  Advanced compression functions
    ***************************************/
    /** ZSTD_estimateCCtxSize() :
     *  Gives the amount of memory allocated for a ZSTD_CCtx given a set of compression parameters.
     *  `frameContentSize` is an optional parameter, provide `0` if unknown */
    pub fn ZSTD_estimateCCtxSize(cParams: ZSTD_compressionParameters)
                                 -> usize;
}
extern "C" {
    /** ZSTD_createCCtx_advanced() :
     *  Create a ZSTD compression context using external alloc and free functions */
    pub fn ZSTD_createCCtx_advanced(customMem: ZSTD_customMem)
                                    -> *mut ZSTD_CCtx;
}
extern "C" {
    /** ZSTD_sizeofCCtx() :
     *  Gives the amount of memory used by a given ZSTD_CCtx */
    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_CCtxParameter {
    ZSTD_p_forceWindow = 0,
    ZSTD_p_forceRawDict = 1,
}
extern "C" {
    /** ZSTD_setCCtxParameter() :
     *  Set advanced parameters, selected through enum ZSTD_CCtxParameter
     *  @result : 0, or an error code (which can be tested with ZSTD_isError()) */
    pub fn ZSTD_setCCtxParameter(cctx: *mut ZSTD_CCtx,
                                 param: ZSTD_CCtxParameter,
                                 value: ::libc::c_uint)
                                 -> usize;
}
extern "C" {
    /** ZSTD_createCDict_byReference() :
     *  Create a digested dictionary for compression
     *  Dictionary content is simply referenced, and therefore stays in dictBuffer.
     *  It is important that dictBuffer outlives CDict, it must remain read accessible throughout the lifetime of CDict */
    pub fn ZSTD_createCDict_byReference(dictBuffer: *const ::libc::c_void,
                                        dictSize: usize,
                                        compressionLevel: ::libc::c_int)
                                        -> *mut ZSTD_CDict;
}
extern "C" {
    /** ZSTD_createCDict_advanced() :
     *  Create a ZSTD_CDict using external alloc and free, and customized compression parameters */
    pub fn ZSTD_createCDict_advanced(dict: *const ::libc::c_void,
                                     dictSize: usize,
                                     byReference: ::libc::c_uint,
                                     cParams: ZSTD_compressionParameters,
                                     customMem: ZSTD_customMem)
                                     -> *mut ZSTD_CDict;
}
extern "C" {
    /** ZSTD_sizeof_CDict() :
     *  Gives the amount of memory used by a given ZSTD_sizeof_CDict */
    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
}
extern "C" {
    /** ZSTD_getCParams() :
    *   @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
    *   `estimatedSrcSize` value is optional, select 0 if not known */
    pub fn ZSTD_getCParams(compressionLevel: ::libc::c_int,
                           estimatedSrcSize: ::libc::c_ulonglong,
                           dictSize: usize)
                           -> ZSTD_compressionParameters;
}
extern "C" {
    /** ZSTD_getParams() :
    *   same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
    *   All fields of `ZSTD_frameParameters` are set to default (0) */
    pub fn ZSTD_getParams(compressionLevel: ::libc::c_int,
                          estimatedSrcSize: ::libc::c_ulonglong,
                          dictSize: usize)
                          -> ZSTD_parameters;
}
extern "C" {
    /** ZSTD_checkCParams() :
    *   Ensure param values remain within authorized range */
    pub fn ZSTD_checkCParams(params: ZSTD_compressionParameters) -> usize;
}
extern "C" {
    /** ZSTD_adjustCParams() :
    *   optimize params for a given `srcSize` and `dictSize`.
    *   both values are optional, select `0` if unknown. */
    pub fn ZSTD_adjustCParams(cPar: ZSTD_compressionParameters,
                              srcSize: ::libc::c_ulonglong, dictSize: usize)
                              -> ZSTD_compressionParameters;
}
extern "C" {
    /** ZSTD_compress_advanced() :
    *   Same as ZSTD_compress_usingDict(), with fine-tune control over each compression parameter */
    pub fn ZSTD_compress_advanced(cctx: *mut ZSTD_CCtx,
                                  dst: *mut ::libc::c_void,
                                  dstCapacity: usize,
                                  src: *const ::libc::c_void,
                                  srcSize: usize,
                                  dict: *const ::libc::c_void,
                                  dictSize: usize, params: ZSTD_parameters)
                                  -> usize;
}
extern "C" {
    /** ZSTD_compress_usingCDict_advanced() :
    *   Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters */
    pub fn ZSTD_compress_usingCDict_advanced(cctx: *mut ZSTD_CCtx,
                                             dst: *mut ::libc::c_void,
                                             dstCapacity: usize,
                                             src: *const ::libc::c_void,
                                             srcSize: usize,
                                             cdict: *const ZSTD_CDict,
                                             fParams: ZSTD_frameParameters)
                                             -> usize;
}
extern "C" {
    /** ZSTD_isFrame() :
     *  Tells if the content of `buffer` starts with a valid Frame Identifier.
     *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
     *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
     *  Note 3 : Skippable Frame Identifiers are considered valid. */
    pub fn ZSTD_isFrame(buffer: *const ::libc::c_void, size: usize)
                        -> ::libc::c_uint;
}
extern "C" {
    /** ZSTD_estimateDCtxSize() :
     *  Gives the potential amount of memory allocated to create a ZSTD_DCtx */
    pub fn ZSTD_estimateDCtxSize() -> usize;
}
extern "C" {
    /** ZSTD_createDCtx_advanced() :
     *  Create a ZSTD decompression context using external alloc and free functions */
    pub fn ZSTD_createDCtx_advanced(customMem: ZSTD_customMem)
                                    -> *mut ZSTD_DCtx;
}
extern "C" {
    /** ZSTD_sizeof_DCtx() :
     *  Gives the amount of memory used by a given ZSTD_DCtx */
    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
}
extern "C" {
    /** ZSTD_createDDict_byReference() :
     *  Create a digested dictionary, ready to start decompression operation without startup delay.
     *  Dictionary content is simply referenced, and therefore stays in dictBuffer.
     *  It is important that dictBuffer outlives DDict, it must remain read accessible throughout the lifetime of DDict */
    pub fn ZSTD_createDDict_byReference(dictBuffer: *const ::libc::c_void,
                                        dictSize: usize)
                                        -> *mut ZSTD_DDict;
}
extern "C" {
    /** ZSTD_createDDict_advanced() :
     *  Create a ZSTD_DDict using external alloc and free, optionally by reference */
    pub fn ZSTD_createDDict_advanced(dict: *const ::libc::c_void,
                                     dictSize: usize,
                                     byReference: ::libc::c_uint,
                                     customMem: ZSTD_customMem)
                                     -> *mut ZSTD_DDict;
}
extern "C" {
    /** ZSTD_sizeof_DDict() :
     *  Gives the amount of memory used by a given ZSTD_DDict */
    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
}
extern "C" {
    /** ZSTD_getDictID_fromDict() :
     *  Provides the dictID stored within dictionary.
     *  if @return == 0, the dictionary is not conformant with Zstandard specification.
     *  It can still be loaded, but as a content-only dictionary. */
    pub fn ZSTD_getDictID_fromDict(dict: *const ::libc::c_void,
                                   dictSize: usize)
                                   -> ::libc::c_uint;
}
extern "C" {
    /** ZSTD_getDictID_fromDDict() :
     *  Provides the dictID of the dictionary loaded into `ddict`.
     *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
     *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
    pub fn ZSTD_getDictID_fromDDict(ddict: *const ZSTD_DDict)
                                    -> ::libc::c_uint;
}
extern "C" {
    /** ZSTD_getDictID_fromFrame() :
     *  Provides the dictID required to decompressed the frame stored within `src`.
     *  If @return == 0, the dictID could not be decoded.
     *  This could for one of the following reasons :
     *  - The frame does not require a dictionary to be decoded (most common case).
     *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.
     *    Note : this use case also happens when using a non-conformant dictionary.
     *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
     *  - This is not a Zstandard frame.
     *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameParams(), which will provide a more precise error code. */
    pub fn ZSTD_getDictID_fromFrame(src: *const ::libc::c_void,
                                    srcSize: usize)
                                    -> ::libc::c_uint;
}
extern "C" {
    /********************************************************************
    *  Advanced streaming functions
    ********************************************************************/
    pub fn ZSTD_createCStream_advanced(customMem: ZSTD_customMem)
                                       -> *mut ZSTD_CStream;
}
extern "C" {
    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_srcSize(zcs: *mut ZSTD_CStream,
                                    compressionLevel: ::libc::c_int,
                                    pledgedSrcSize: ::libc::c_ulonglong)
                                    -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingDict(zcs: *mut ZSTD_CStream,
                                      dict: *const ::libc::c_void,
                                      dictSize: usize,
                                      compressionLevel: ::libc::c_int)
                                      -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_advanced(zcs: *mut ZSTD_CStream,
                                     dict: *const ::libc::c_void,
                                     dictSize: usize,
                                     params: ZSTD_parameters,
                                     pledgedSrcSize: ::libc::c_ulonglong)
                                     -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingCDict(zcs: *mut ZSTD_CStream,
                                       cdict: *const ZSTD_CDict)
                                       -> usize;
}
extern "C" {
    pub fn ZSTD_initCStream_usingCDict_advanced(zcs: *mut ZSTD_CStream,
                                                cdict: *const ZSTD_CDict,
                                                pledgedSrcSize:
                                                    ::libc::c_ulonglong,
                                                fParams: ZSTD_frameParameters)
-> usize;
}
extern "C" {
    /** ZSTD_resetCStream() :
     *  start a new compression job, using same parameters from previous job.
     *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place..
     *  Note that zcs must be init at least once before using ZSTD_resetCStream().
     *  pledgedSrcSize==0 means "srcSize unknown".
     *  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
     *  @return : 0, or an error code (which can be tested using ZSTD_isError()) */
    pub fn ZSTD_resetCStream(zcs: *mut ZSTD_CStream,
                             pledgedSrcSize: ::libc::c_ulonglong)
                             -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_DStreamParameter_e {
    DStream_p_maxWindowSize = 0,
}
extern "C" {
    pub fn ZSTD_createDStream_advanced(customMem: ZSTD_customMem)
                                       -> *mut ZSTD_DStream;
}
extern "C" {
    pub fn ZSTD_initDStream_usingDict(zds: *mut ZSTD_DStream,
                                      dict: *const ::libc::c_void,
                                      dictSize: usize)
                                      -> usize;
}
extern "C" {
    pub fn ZSTD_setDStreamParameter(zds: *mut ZSTD_DStream,
                                    paramType: ZSTD_DStreamParameter_e,
                                    paramValue: ::libc::c_uint)
                                    -> usize;
}
extern "C" {
    pub fn ZSTD_initDStream_usingDDict(zds: *mut ZSTD_DStream,
                                       ddict: *const ZSTD_DDict)
                                       -> usize;
}
extern "C" {
    pub fn ZSTD_resetDStream(zds: *mut ZSTD_DStream) -> usize;
}
extern "C" {
    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
}
extern "C" {
    /**
  Buffer-less streaming compression (synchronous mode)

  A ZSTD_CCtx object is required to track streaming operations.
  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
  ZSTD_CCtx object can be re-used multiple times within successive compression operations.

  Start by initializing a context.
  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,
  or ZSTD_compressBegin_advanced(), for finer parameter control.
  It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()

  Then, consume your input using ZSTD_compressContinue().
  There are some important considerations to keep in mind when using this advanced function :
  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffer only.
  - Interface is synchronous : input is consumed entirely and produce 1+ (or more) compressed blocks.
  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
    Worst case evaluation is provided by ZSTD_compressBound().
    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
    In which case, it will "discard" the relevant memory section from its history.

  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
  Without last block mark, frames will be considered unfinished (corrupted) by decoders.

  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress some new frame.
*/
    pub fn ZSTD_compressBegin(cctx: *mut ZSTD_CCtx,
                              compressionLevel: ::libc::c_int)
                              -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingDict(cctx: *mut ZSTD_CCtx,
                                        dict: *const ::libc::c_void,
                                        dictSize: usize,
                                        compressionLevel: ::libc::c_int)
                                        -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_advanced(cctx: *mut ZSTD_CCtx,
                                       dict: *const ::libc::c_void,
                                       dictSize: usize,
                                       params: ZSTD_parameters,
                                       pledgedSrcSize: ::libc::c_ulonglong)
                                       -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingCDict(cctx: *mut ZSTD_CCtx,
                                         cdict: *const ZSTD_CDict)
                                         -> usize;
}
extern "C" {
    pub fn ZSTD_compressBegin_usingCDict_advanced(cctx: *const ZSTD_CCtx,
                                                  cdict: *const ZSTD_CDict,
                                                  fParams:
                                                      ZSTD_frameParameters,
                                                  pledgedSrcSize:
                                                      ::libc::c_ulonglong)
-> usize;
}
extern "C" {
    pub fn ZSTD_copyCCtx(cctx: *mut ZSTD_CCtx,
                         preparedCCtx: *const ZSTD_CCtx,
                         pledgedSrcSize: ::libc::c_ulonglong)
                         -> usize;
}
extern "C" {
    pub fn ZSTD_compressContinue(cctx: *mut ZSTD_CCtx,
                                 dst: *mut ::libc::c_void,
                                 dstCapacity: usize,
                                 src: *const ::libc::c_void, srcSize: usize)
                                 -> usize;
}
extern "C" {
    pub fn ZSTD_compressEnd(cctx: *mut ZSTD_CCtx, dst: *mut ::libc::c_void,
                            dstCapacity: usize, src: *const ::libc::c_void,
                            srcSize: usize)
                            -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ZSTD_frameParams {
    pub frameContentSize: ::libc::c_ulonglong,
    pub windowSize: ::libc::c_uint,
    pub dictID: ::libc::c_uint,
    pub checksumFlag: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_ZSTD_frameParams() {
    assert_eq!(::core::mem::size_of::<ZSTD_frameParams>(),
               24usize,
               concat!("Size of: ", stringify!(ZSTD_frameParams)));
    assert_eq!(::core::mem::align_of::<ZSTD_frameParams>(),
               8usize,
               concat!("Alignment of ", stringify!(ZSTD_frameParams)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParams)).frameContentSize as
                   *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParams),
                       "::",
                       stringify!(frameContentSize)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParams)).windowSize as
                   *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParams),
                       "::",
                       stringify!(windowSize)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParams)).dictID as *const _ as
                   usize
               },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParams),
                       "::",
                       stringify!(dictID)));
    assert_eq!(unsafe {
                   &(*(0 as *const ZSTD_frameParams)).checksumFlag as
                   *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(ZSTD_frameParams),
                       "::",
                       stringify!(checksumFlag)));
}
impl Clone for ZSTD_frameParams {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    pub fn ZSTD_getFrameParams(fparamsPtr: *mut ZSTD_frameParams,
                               src: *const ::libc::c_void, srcSize: usize)
                               -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBegin(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBegin_usingDict(dctx: *mut ZSTD_DCtx,
                                          dict: *const ::libc::c_void,
                                          dictSize: usize)
                                          -> usize;
}
extern "C" {
    pub fn ZSTD_copyDCtx(dctx: *mut ZSTD_DCtx,
                         preparedDCtx: *const ZSTD_DCtx);
}
extern "C" {
    pub fn ZSTD_nextSrcSizeToDecompress(dctx: *mut ZSTD_DCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_decompressContinue(dctx: *mut ZSTD_DCtx,
                                   dst: *mut ::libc::c_void,
                                   dstCapacity: usize,
                                   src: *const ::libc::c_void,
                                   srcSize: usize)
                                   -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZSTD_nextInputType_e {
    ZSTDnit_frameHeader = 0,
    ZSTDnit_blockHeader = 1,
    ZSTDnit_block = 2,
    ZSTDnit_lastBlock = 3,
    ZSTDnit_checksum = 4,
    ZSTDnit_skippableFrame = 5,
}
extern "C" {
    pub fn ZSTD_nextInputType(dctx: *mut ZSTD_DCtx) -> ZSTD_nextInputType_e;
}
extern "C" {
    pub fn ZSTD_getBlockSizeMax(cctx: *mut ZSTD_CCtx) -> usize;
}
extern "C" {
    pub fn ZSTD_compressBlock(cctx: *mut ZSTD_CCtx,
                              dst: *mut ::libc::c_void, dstCapacity: usize,
                              src: *const ::libc::c_void, srcSize: usize)
                              -> usize;
}
extern "C" {
    pub fn ZSTD_decompressBlock(dctx: *mut ZSTD_DCtx,
                                dst: *mut ::libc::c_void,
                                dstCapacity: usize,
                                src: *const ::libc::c_void, srcSize: usize)
                                -> usize;
}
extern "C" {
    pub fn ZSTD_insertBlock(dctx: *mut ZSTD_DCtx,
                            blockStart: *const ::libc::c_void,
                            blockSize: usize)
                            -> usize;
}
extern "C" {
    /** ZDICT_trainFromBuffer() :
    Train a dictionary from an array of samples.
    Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
    supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
    The resulting dictionary will be saved into `dictBuffer`.
    @return : size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
              or an error code, which can be tested with ZDICT_isError().
    Tips : In general, a reasonable dictionary has a size of ~ 100 KB.
           It's obviously possible to target smaller or larger ones, just by specifying different `dictBufferCapacity`.
           In general, it's recommended to provide a few thousands samples, but this can vary a lot.
           It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
*/
    pub fn ZDICT_trainFromBuffer(dictBuffer: *mut ::libc::c_void,
                                 dictBufferCapacity: usize,
                                 samplesBuffer: *const ::libc::c_void,
                                 samplesSizes: *const usize,
                                 nbSamples: ::libc::c_uint)
                                 -> usize;
}
extern "C" {
    pub fn ZDICT_getDictID(dictBuffer: *const ::libc::c_void,
                           dictSize: usize)
                           -> ::libc::c_uint;
}
extern "C" {
    pub fn ZDICT_isError(errorCode: usize) -> ::libc::c_uint;
}
extern "C" {
    pub fn ZDICT_getErrorName(errorCode: usize) -> *const ::libc::c_char;
}
